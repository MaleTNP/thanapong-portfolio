SECTION 3: Hibernate/JPA CRUD

<< HIBERNATE / JPA OVERVIEW >>
Topcis
 - What is Hibernate?
 - Benefits of Hibernate
 - What is JPA?
 - Benefits of JPA
 - Code Snippets

What is Hibernate?
 - A framework for persisting / saving Java objects in a database.
   - www.hibernate.org/orm

.------.      .-----------.      .-----.
| Your | ---> |           | ---> |-----|
| Java |      | Hibernate |      |-----|
| App  | <--- |           | <--- |-----|
'------'      '-----------'      '-----'

Benefits of Hibernate
 - Handles all of the low-level SQL
 - Minimize the amount of JDBC code you have to develop
 - Provides the Object-to-Relational Mapping (ORM)

Object-To-Relational Mapping (ORM)
 - The developer defines mapping between Java class and database table

     Java Class                                     Database Table    
.-------------------.                         .------------------------.
|     Student       |      .-----------.      | student              V |
|-------------------|      |           |      |------------------------|
| id: int           | ---> |           | ---> | id INT                 |
| firstName: String |      | Hibernate |      | first_name VARCHAR(45) |
| lastName: String  | <--- |           | <--- | last_name  VARCHAR(45) |
| email: String     |      |           |      | email VARCHAR(45)      |
'-------------------'      '-----------'      |------------------------|
                                              | Indexes              > |
                                              '------------------------'

What is JPA?
 - Jakarta Persistence API (JPA) ... previously known as Java Persistence API
   - Standard API for Object-to-Relational-Mapping (ORM)

 - Only a specification
   - Defines a set of interfaces
   - Requires an implementation to be useable


JPA-Vendor Implementations
JPA Spec
 |-- Hibernate
 '-- EclipseLink
www.luv2code.com/jpa-vendors

What are Benefits of JPA
 - By having a standard API, you are not locked to vendor's implementation
 - Maintain portable, flexible code by coding to JPA spec (interfaces)
 - Can theoretically switch vendor implementations 
   - For example, if Vendor ABC stops supporting their product
   - You could switch to Vendor XYZ without vendor lock in

JPA - Vendor Implementations

.------------.
| My Biz App |
'------------'
 .----------.
 | JPA Spec |<------.
 '----------'       |
      ^             X
      |             |
.-----------. .-------------.
| Hibernate | | EclipseLink |
'-----------' '-------------'

Saving a Java Object with JPA
----------------------------------
// create Java object
Student theStudent = new Student("Paul", "Doe", "paul@outlook.com");

// save it to data base
entityManager.persist(theStudent);
^^^^^^^^^^^^^ ^^^^^^^
 |             '-- The data will be stored in the database SQL insert
 '---------------- Special JPA helper object
----------------------------------

Retrieving a Java Object with JPA
----------------------------------
// create Java Object
Student theStudent = new Student("Paul", "Doe", "paul@outlook.com");

// save it ot database
entityManager.persist(theStudent);

// now retrieve from database using the primary key
int theId = 1;
Student myStudent = entityManager.find(Student.class, theId);
                                  ^^^^
                                   '-- Query the database given id
----------------------------------

Querying for Java Objects
----------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery("from Student", Student.class);
List<Student> students = theQuery.getResultList();
                                  ^^^^^^^^^^^^^^^
                                   '--> Returen a list of Student objects from the database
----------------------------------

JPA/Hibernate CRUD Apps
 - Create objects
 - Read   objects
 - Update objects
 - Delete objects


<< HIBERNATE, JPA AND JDBC >>

How does Hibernate / JPA relate to JDBC?
Hibernate / JPA and JDBC
 - Hibernate/JPA uses JDBC for all database communications

.------.      .-----------..------.      .-----.
| Your | ---> |    JPA    ||      | ---> |-----|
| Java |      | Hibernate || JDBC |      |-----|
| App  | <--- |           ||      | <--- |-----|
'------'      '-----------''------'      '-----'

Hibernate/JPA actually uses JDBC for all database communications.
So, Hibernate/JPA is just another layer of abstraction on top of JDBC.
So when your application uses the Hibernate/JPA framework,
your app will actually store and retrieve the objects using the JPA API.
Hibernate/JPA does a lot the low-level work for you, but in the background,
it all goes through the standard JDBC API.

Hibernate/JPA makes use of JDBC in the background for communicating with the database.


<< SETTING UP DEVELOPMENT ENVIRONMENT >>
MySQL Database
 - In this course, we will use the MySQL Database
 - MySQL includes two components
   - MySQL Database Server
   - MySQL Workbench

MySQL Database Server
 - The MySQL Database Server is the main engine of the database
 - Stores data for the database
 - Supports CRUD features on the data


MySQL Workbench
 - MySQL Workbench is a client GUI for interacting with the database
 - Create database schemas and tables
 - Execute SQL queries to retrieve data
 - Perform insert, updates and deletes on data
 - Handle administrative functions such as creating users
 - Other ...

Install the MySQL software
 - Step 1: Instsall MySQL Database Server
   - https://dev.mysql.com/download/mysql/
 - Step 2: Install MySQL Workbench
   - https//dev.mysql.com/download/workbench/


<< SETTING UP DATABASE TABLE >>
Two Database Scripts
1. Folder: 00-starter-sql-scripts
   - 01-create-user.sql
   - 02-student-tracker.sql

About: 01-create-user.sql
1. Create a new MySQL user for our application
   - user id: springstudent
   - password: springstudent

File: 01-create-user.sql
----------------------------------
-- Drop user first if they exist
DROP USER if exists 'springstudent'@'%';

-- Now create user with prop privileges
CREATE USER 'springstudent'@'%' IDENTIFIED BY 'springstudent';

GRANT ALL PRIVILEGES ON * . * TO 'springstudent'@'%';
----------------------------------

About: 02-student-tracker.sql
1. Create a new database table: student

.------------------------.
| student              V |
|------------------------|
| id INT                 |
| first_name VARCHAR(45) |
| last_name  VARCHAR(45) |
| email VARCHAR(45)      |
|------------------------|
| Indexes              > |
'------------------------'

File: 02-student-tracker.sql
----------------------------------
CREATE DATABASE IF NOT EXISTS `student_tracker`;
USE `student_tracker`;

--
-- Table structure for table `student`
--

DROP TABLE IF EXISTS `student`;

CREATE TABLE `student` (
  `id` int NOT NULL AUTO_INCREMENT,
  `first_name` varchar(45) DEFAULT NULL,
  `last_name`  varchar(45) DEFAULT NULL,
  `email` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
----------------------------------

MySQL Workbench: SCHEMAS
----------------------------------
student_tracker
'-- Tables
'   '-- student
'       '-- Columns
'       '   '-- id
'       '   '-- first_name
'       '   '-- last_name
'       '   '-- email
'       '-- Indexes
'       '-- Foreign Keys
'       '-- Triggers
'-- Views
'-- Stored Procedures
'-- Functions
sys
----------------------------------


<< SETTING UP SPRING BOOT PROJECT >>
Automatic Data Source Configuration
 - In Spring Boot, Hibernate is the default implementation of JPA
 - EntityManager is main component for creating queries etc ...
 - EntityManager is from Jakarta Persistence API (JPA)
 - Based on configs, Spring Boot will automatically create the beans:
   - DataSource, EntityManager, ...
 - You can then inject these into your app, for example your DAO

Setting up Project with Spring Initialzr
 - At Spring Initialzr website, start.spring.io
 - Add dependencies
   - MySQL Driver: mysql-connector-j
   - Spring Data JPA: spring-boot

Spring Boot - Auto configuration
 - Spring Boot will automatically configure your data source for you
 - Based on entries from Maven pom file
   - JDBC Driver: mysql-connector-j
   - Spring Data (ORM): spring-boot-starter-data-jpa
 - DB connection info from application.properties

File: application.properties
----------------------------------
spring.datasource.url=jdbc:mysql://localhost:3306/student_tracker
spring.datasource.username=springstudent
spring.datasource.password=springstudent
----------------------------------

No need to five JDBC driver class name
Spring Boot will automatically detect it based on URL

Creating Spring Boot - Command Line App
 - We will create a Spring Boot - Command Line App
 - This will allow us to focus on Hibernate / JPA
 - Later in the course, we will apply this to a CRUD REST API

File: CruddemoApplication.java
----------------------------------
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
public class CruddemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(CruddemoApplication.class, args);
  }

  @Bean
  public CommandLineRunner commandLineRunner(String[] args) {
    return runner -> {
      System.out.println("Hello world");
    }
  }
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   '--> Executed after the Spring Beans have been loaded

}

----------------------------------

We want to turn off the Spring Boot banner

File: application.properties
----------------------------------
...

# Turn off the Spring Boot banner
spring.main.banner-mode=off
----------------------------------

We to reduce the loggin level
Set level to: warn
This will only show warning and errors

File: application.properties
----------------------------------
...

# Reduce loggin level. Set loggin level to warn
logging.level.root=warn
----------------------------------


<< JPA ANNOTATION >>
JPA Dev Process - To Do List
1. Annotate Java Class
2. Develope Java Code to perform database operations

Let's just say "JPA"
 - As mentioned, Hibernate is the default JPA implementation in Spring Boot
 - Going forward in this course, I will simply use the term: JPA
   - Instead of saying "JPA Hibernate"
 - We know that by default, Hibernate is used behind the scenes

Terminology
Entity Class: Java class that is mapped to a database table

Object-to-Relational Mapping (ORM)

     Java Class                                     Database Table    
.-------------------.                         .------------------------.
|     Student       |      .-----------.      | student              V |
|-------------------|      |           |      |------------------------|
| id: int           | ---> |           | ---> | id INT                 |
| firstName: String |      |    JPA    |      | first_name VARCHAR(45) |
| lastName: String  | <--- |           | <--- | last_name  VARCHAR(45) |
| email: String     |      |           |      | email VARCHAR(45)      |
'-------------------'      '-----------'      |------------------------|
                                              | Indexes              > |
                                              '------------------------'
Entity Class
 - At minimum, the Entity class
   - Must be annotated with @Entity
   - Must have a public or protected no-argument constructor
     - The class can have other constructors

Constructors in Java - Refresher
 - Remember about constructors in Java
 - If you don't declare any constructors
   - Java will provide a no-argument constructor for free
 - If you declare constructors with arguments
   - then you do NOT get a no-argument constructor for free
   - In this case, you have to explicityly declare a no-argument constructor

Java Annotations
 - Step 1: Map class to database table
 - Step 2: Map fields to database columns

File: 
----------------------------------
@Entity
@Table(name="student")
public class Student{

  @Id
  @Column(name="id")
  private int id;

  @Column(name="first_name")
  private String firstName;

  ...

}
----------------------------------

     Java Class                 Database Table    
.-------------------.    .------------------------.
|     Student ------------>student              V |
|-------------------|    |------------------------|
| id: int ---------------->id INT                 |
| firstName: String ------>first_name VARCHAR(45) |
| lastName: String  |    | last_name  VARCHAR(45) |
| email: String     |    | email VARCHAR(45)      |
'-------------------'    |------------------------|
                         | Indexes              > |
                         '------------------------'

@Column - Optional
 - Actually, hte use of @Column is optional
 - If not specified, the column name is the same name as Java field
 - In general, I don't recommend this approach
   - If you refactor the Java code, then it will not match existing database column
   - This is a breaking change and you will need to update database column

 - Same applies to @Table, database table name is same as the class

Terminology
Primary Key
Uniquely indentifies each row in a table
Must be a unique value
Cannot contain NULL values

MySQL - Auto Increment

File: 02-student-tracker.sql
----------------------------------
...

CREATE TABLE `student` (
  `id` int NOT NULL AUTO_INCREMENT,  <--
  `first_name` varchar(45) DEFAULT NULL,
  `last_name`  varchar(45) DEFAULT NULL,
  `email` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)  <--
  )
----------------------------------

JPA Identity - Primary Key

File: Student.java  Package: com.thanapong.cruddemo.entity
----------------------------------
@Entity
@Table(name="student")
public class Student{

  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY)
  @Column(name="id")
  private int id;

  ...

}
----------------------------------

ID Generation Strategies

.-------------------------.-------------------------------------------------.
|          Name           |                   Description                   |
|-------------------------+-------------------------------------------------|
| GenerationType.AUTO     | Pick an appropriate strategy for the particular |
|                         | database                                        |
|-------------------------+-------------------------------------------------|
| GenerationType.IDENTITY | Assign primary keys using database identity     |
|                         | column                                          |
|-------------------------+-------------------------------------------------|
| GenerationType.SEQUENCE | Assign primary keys using a database sequence   |
|                         |                                                 |
|-------------------------+-------------------------------------------------|
| GeneraitonType.TABLE    | Assign primary keys using an underlying         |
|                         | database table to ensure uniqueness             |
|-------------------------+-------------------------------------------------|
| GenerationType.UUID     | Assign primary keys using a globally unique     |
|                         | identifier (UUID) to ensure uniqueness          |
'-------------------------'-------------------------------------------------'

Bonus Bonus
 - You can define your own CUSTOM generation strategy
 - Create implementation of org.hebernate.id.IdentifierGenerator
 - Override the method: public Serializable generate(...)


<< JPA ANNOTATION - CODING >>

File: Student.java  Package: com.thanapong.cruddemo.entity
----------------------------------
...

@Entity
@Table(name="student")
public class Student{

  // define fields
  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY)
  @Column(name="id")
  private int id;

  @Column(name="first_name")
  private String firstName;

  @Column(name="last_name")
  private String lastName;

  @Column(name="email")
  private String email;

  // define constructors
  public Student(String firstName, String lastName, String email) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
  }

  // define getter/setter
  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  // define toString() method
  @Override
  public String toString() {
    return "Student(" +
           "id=" + id +
           ", firstName='" + firstName + "\'" +
           ", lastName='" + lastName + "\'" +
           ", email='" + email +  "\'" +
           ')';
  }

}
----------------------------------


<< SAVING A JAVA OBJECT WITH JPA >>
Sample App Features
 - Create a new Student
 - Read a Student
 - Update a Student
 - Delete a Student

Student Data Access Object
 - Responsible for interfacing with the database
 - This a common design pattern: Data Access Object (DAO)

                Data Access Object
.----------.      .-----------.      .-----.
| Cruddemo | <--> |  Student  | <--> |-----|
|    App   |      |    DAO    |      |-----|
'----------'      '-----------'      '-----'

Student Data Access Object 
Methods
 - save(...)
 - findById(...)
 - findAll()
 - findByLastName(...)
 - update(...)
 - delete(...)
 - deleteAll()

Student Data Access Object 
 - Our DAO need a JPA Entity Manager
 - JPA Enitity Manager is the main component for saving/retrieving entities

Data Access Object
  .---------.      .---------.      .-------.      .-----.
  | Student | <--> |  Entity | <--> |  ...  | <--> |-----|
  |   DAO   |      | Manager |      |       |      |-----|
  '---------'      '---------'      '-------'      '-----'

JPA Entity Manager
 - Our JPA Entity Manager needs a Data Source
 - The Data Source defines database connection info
 - JPA Entity Manager and Data Source are automatically created by Spring Boot
   - Based on the file: application.properties (JDBC URL, use id, password, etc ...)
 - We can autowire / inject the JPA Entity Manager into our Student DAO

Data Access Object
  .---------.      .---------.      .--------.      .-----.
  | Student | <--> |  Entity | <--> |  Data  | <--> |-----|
  |   DAO   |      | Manager |      | Source |      |-----|
  '---------'      '---------'      '--------'      '-----'

What about JpaRepository???
 - Spring Data JPA has a JpaRepository interface
 - This provides JPA database access with minimal coding

Which One EntityManager or JpaRepository???

Answer
 - Yes, we will use JpaRepository in this course
 - We will cover it later inthe course
 - In this course, I want to show you various techniques for using JPA
 - Knowing BOTH EntityManager and JpaRepository will help you on future projects

In Simple Terms
 - If you need low-level control and flexibility, EntityManager
 - If you want high-level of abstraction, use JpaRepository

Use Case

Entity Manager                                       JpaRepository
.-------------------------------------------------. .-------------------------------------------.
| - Need low-level control er the database        | | - Provides commonly used CRUD             |
|   perations and want ot write custom queries    | |   operations out of the box, reducing the |
|                                                 | |   amount of code you need to write        |
| - Provides low-level access to JPA and work     | |                                           |
|   directly with JPA entities                    | | - Additional features such as pagination, |
|                                                 | |   sorting                                 |
| - Complex queries that required advanced        | |                                           |
|   features such as native SQL queries or stored | | - Generate queries based on method names  |
|   procedure calls                               | |                                           |
|                                                 | | - Can also create custom queries using    |
| - When you have custom requirements that        | |   @Query                                  |
|   are easily handled by higher-level            | |                                           |
|   abstractoins                                  | |                                           |
'-------------------------------------------------' '-------------------------------------------'

My Recommendation
 - Choice depends on the application requirements and developer preference
 - You can also use both in the same project

 - For learning purposes, start with EnitityManager then learn JpaRepository
 - This will help you understand the low-level coding behind the scenes
 - Knowing BOTH EntityManager and JpaRepository will help you on future projects


Student DAO - Dev Process
 - Step 1: Define DAO interface
 - Step 2: Define DAO implementation
   - Inject the entity manager
 - Step 3: Update main app

Data Access Object
  .---------.      .---------.      .--------.      .-----.
  | Student | <--> |  Entity | <--> |  Data  | <--> |-----|
  |   DAO   |      | Manager |      | Source |      |-----|
  '---------'      '---------'      '--------'      '-----'

Step 1: Define DAO interface

File: StudentDAO.java
----------------------------------
import com.thanapong.cruddemo.entity.Student;

public interface StudentDAO {
  
  void save(Student theStudent);

}
----------------------------------


Step 2: Define DAO implementation
File: StudentDAOImpl.java
----------------------------------
import ...

@Repository
^^^^^^^^^^^
 '--> Specialized annotation for repositories
      Supports component scanning
      Translates JDBC exceptions

public class StudentDAOImpl implements StudentDAO {

  // define field for entity manager
  private EntityManager entityManager;

  // inject entity manager using constructor injection
  @Autowired
  public StudentDAOImpl(EntityManager theEntityManager) {
    entityManager = theEntityManager;
  }

  // implement save method
  // add @Transactional since we are performing an update
  @Override
  @Transactional    
  public void save(Student theStudent) {
    entityManager.persist(theStudent);
  }
}

----------------------------------

     Java Class                                     Database Table    
.-------------------.                         .------------------------.
|     Student       |      .-----------.      | student              V |
|-------------------|      |           |      |------------------------|
| id: int           | ---> |           | ---> | id INT                 |
| firstName: String |      |    JPA    |      | first_name VARCHAR(45) |
| lastName: String  | <--- |           | <--- | last_name  VARCHAR(45) |
| email: String     |      |           |      | email VARCHAR(45)      |
'-------------------'      '-----------'      |------------------------|
                                              | Indexes              > |
                                              '------------------------'
Spring @Transactional
 - Spring provides an @Transactional annotation
 - Autmagically begin and end a transaction for your JPA code
   - No need for you to explicityly do this in your code

Specialized Annotation for DAOs
 - Spring provides the @Repository annotation

                    .------------.
    .-------------->| @Component |<------.
    |               '------------'       |
    |                      ^             |
    |                      |             |
.-----------------. .-------------. .-----------. 
| @RestController | | @Repository | |    ...    |  
'-----------------' '-------------' '-----------'


 - Applied to DAO implementations

 - Spring will automatically register the DAO implementation
   - thanks to component-scanning

 - Spring also provides translation of any JDBC related exceptions

Step 3: Update main app

File: CruddemoApplication.java
----------------------------------
import ...

@SpringBootApplication
public class CruddemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(CruddemoApplication.class, args);
  }

  @Bean
  public CommandLineRunner commandLineRunner(StudentDAO studentDAO) {
    return runner -> {
      createStudent(studentDAO);
    }
  }

  private void createStudent(StudentDAO studentDAO) {
    
    // create the student object
    System.out.println("Create new student object...");
    Student tempStudent = new Student("Paul", "Doe", "paul@outlook.com");

    // save the student object
    System.out.println("Saving the student...");
    studentDAO.save(tempStudent);

    // display id of the saved student
    System.out.println("Saved student, Generated id: " + tempStudent.getId());
  }

}
----------------------------------


<< CHANGING INDEX OF MYSQL AUTO INCREMENT >>
How do I change the AUTO_INCREMENT values?

1. Open SQL workbench and write some code

File: 
----------------------------------
ALTER TABLE student_tracker.student AUTO_INCREMENT=3000
----------------------------------

2. Click lightning bolt to execute it
3. Go back to our application, and run our application again

How do I RESET the AUTO_INCREMENT values to 1?

1. Open SQL workbench and write some code

File: 
----------------------------------
TRUNCATE student_tracker.student
----------------------------------

2. Click lightning bolt to execute it

Remove all data from the database table Reset AUTO_INCREMENT starting with 1


<< READING OBJECTS WITH JPA >>

File: 
----------------------------------
Retrieving a Java Object with JPA
// retrieve/read from database using the primary key
// in this example, retrieve Student with primary key: 1

Student myStudent = EntityManager.find(Student.class, 1);
                                       ^^^^^^^        ^
                         Entity class <--'            '--> Primary key 
----------------------------------

Development Process
1. Add new method to DAO interface

File: StudentDAO.java
----------------------------------
import com.thanapong.cruddemo.entity.Student;

public interface StudentDAO {
  
  ...

  Student findById(Integer id);   <--

}
----------------------------------

2. Add new method to DAO implementation

File: StudentDAOImpl.java
----------------------------------
import ...

@Repository
public class StudentDAOImpl implements StudentDAO {

  private EntityManager entityManager;

  ...
  
  @Override    <--
  public Student findById(Integer id) {
    return EntityManager.find(Student.class, id);
  }   <--
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   '--> No need to add @Transactional since we are doing a query
}

----------------------------------


3. Update main app

File: CruddemoApplication.java
----------------------------------
import ...

@SpringBootApplication
public class CruddemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(CruddemoApplication.class, args);
  }

  @Bean
  public CommandLineRunner commandLineRunner(StudentDAO studentDAO) {
    return runner -> {
      readStudent(studentDAO);   <---
    }
  }

  private void readStudent(StudentDAO studentDAO) {   <---
    // create a student object
    System.out.println("Creating new student object...");
    Student tempStudent = new Student("Daffy", "Duck", "daffy@outlook.com");

    // save the student object
    System.out.println("Saving the student...");
    studentDAO.save(tempStudent);

    // display id of the saved student
    System.out.println("Saved student. Generated id: " + tempStudent.getId());

    // retrieve student based on the id: primary key
    System.out.println("\nRetrieving student with id: " + tempStudent.getId());

    Student myStudent = studentDAO.findById(tempStudent.getId());

    System.out.println("Found the student: " + myStudent);
  }    <---

  ...

}
----------------------------------


<< QUERYING OBJECTS WITH JPA >>
JPA Query Language (JPQL)
 - Query language for retrieving objects
 - Similar in concept to SQL
   - where, like, order by, join, in, etc...
 - However, JPQL is based on entity name and entity fields

Retrieving all Students

file:
----------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student", Student.class);
List<Student> students = theQuery.getResultList();        ^^^^^^^^^^^^
                                                           | |
Note: this is NOT the name of the database table <---------' '--> Name of JPA Entity ...
All JPQL syntax is based on entity name and entity fields         the class name
----------------------------------

Retrieving Students: lastName = 'DOE'

file:
----------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery(
					"FROM Student WHERE lastName='DOE'", Student.class);
List<Student> students = theQuery.getResultList();          ^^^^^^^^
                                                             '--> Field of JPA Entity
----------------------------------

Retrieving Students using OR predicate:

file:
----------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery(
			"FROM Student WHERE lastName='DOE' OR firstName='Daffy'", Student.class);
List<Student> students = theQuery.getResultList();             ^^^^^^^^
                                                                 '--> Field of JPA Entity
----------------------------------

Retrieving Students using LIKE predicate:
file:
----------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery(
			"FROM Student WHERE email LIKE '%outlook.com'", Student.class);
List<Student> students = theQuery.getResultList();      ^^^^^^^^^^^^
                                                         '--> Match of email addresses that ends with
----------------------------------

JPQL - Named Parameters

file:
----------------------------------
public List<Student> findByLastName(String theLastName) {
  
  TypedQuery<Student> theQuery = entityManager.createQuery(
			"FROM Student WHERE lastName=:theData", Student.class);
						      ^^^^^^^
						       '-------------.
           Think of this as a place holder that is filled in later --'
           JPQL Named Parameter are prefixed with a colon :

  theQuery.setParameter("theData", theLastName);

  return theQuery.getResultList();
}
----------------------------------

JPQL - select clause
 - The query wxamples so far did not specify a "select" clause
 - The Hibernate implementation is lenient and allow Hibernate Query Language (HQL)
 - For strict JPQL, the "select" clause is required

file:
----------------------------------
TypedQuery<Student> theQuery = 
		entityManager.createQuery("select s FROM Student s", Student.class);
					   ^^^^^^^^
                                            '----------------.
		s is an "identification variable" / aliase --'
		Provides a reference to the Student entity object
		s - Can be any name, Useful for when you have complex queries
			
----------------------------------

 - Other examples, for strict JPQL

file:
----------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery(
		"select s FROM Student s WHERE s.email LIKE '%outlook.com'", Student.class);
                 ^^^^^^^^      ^^^^^^^^^       ^^^^^^^	   
----------------------------------

file:
----------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery(
		"select s FROM Student s WHERE s.lastName=:theData", Student.class);
                 ^^^^^^^^      ^^^^^^^^^       ^^^^^^^	   
----------------------------------

Development Process
1. Add new method to DAO interface

file: StudentDAO.java
----------------------------------
import ...

public interface StudentDAO {
   
  ...

  List<Student> findAll();  <---

}
----------------------------------

2. Add new method to DAO implementation

file: StudentDAOImpl.java
----------------------------------
import ...

public class StudentDAOImpl implements StudentDAO {

  private EntityManager entityManager;
  ...

  @Override  <---
  public List<Student> findAll() {
    TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student", Student.class);
    return theQuery.getResultList();
  }  <---

}
----------------------------------

3. Update main app

File: CruddemoApplication.java
----------------------------------
import ...

@SpringBootApplication
public class CruddemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(CruddemoApplication.class, args);
  }

  @Bean
  public CommandLineRunner commandLineRunner(StudentDAO studentDAO) {
    return runner -> {
      queryForStudents(studentDAO);   <---
    }
  }

  private void queryForStudents(StudentDAO studentDAO) {  <---

    // get list of students
    List<Student> theStudents = studentDAO.findAll();

    // display list of students
    for (Student tempStudent : theStudents) {
      System.out.println(tempStudent);
    }
  }   <---

  ...

}
----------------------------------


<< UPDATING OBJECTS WITH JPA >>

Update a Student

File: StudentDAOImpl.java
----------------------------------
Student theStudent = enityManager.find(Student.class, 1);

// change first name to "Scooby"
theStudent.setFirstName("Scooby");

entityManager.merge(theStudent);
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 '--> Update the entity
----------------------------------

Update last name for all students

File: StudentDAOImpl.java
----------------------------------
int numRowUpdated = entityManager.createQuery(
			"UPDATE Student SET lastName='Tester'")
			.executeUpdate();
			 ^^^^^^^^^^^^^^^
			  '--> Execute this statement
----------------------------------

Development Process
1. Add new method to DAO interface

file: StudentDAO.java
----------------------------------
import ...

public interface StudentDAO {
  ...

  void update(Student theStudent);  <---
}
----------------------------------

2. Add new method to DAO implementation

file: StudentDAOImpl.java
----------------------------------
import ...

public class StudentDAOImpl implements StudentDAO {

  private EntityManager entityManager;
  ...

  @Override  <---
  @Transactional
  public void update(Student theStudent) {
    entityManager.merge(theStudent);
  }  <---

}
----------------------------------

3. Update main app

File: CruddemoApplication.java
----------------------------------
import ...

@SpringBootApplication
public class CruddemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(CruddemoApplication.class, args);
  }

  @Bean
  public CommandLineRunner commandLineRunner(StudentDAO studentDAO) {
    return runner -> {
      updateStudent(studentDAO);   <---
    }
  }

  private void updateStudent(StudentDAO studentDAO) {   <---
    // retrieve student based on the id: primary key
    int studentId = 1;
    System.out.println("Getting student with id: " + studentId);

    Student myStudent = studentDAO.findById(studentId);

    System.out.println("Updating student...");

    // change first name to "Scooby"
    myStudent.setFirstName("Scooby");
    studentDAO.update(myStudent);

    // display updated student
    System.out.println("Updated student: " + myStudent);
  }   <---

  ...
}
----------------------------------


<< DELETING OBJECTS WITH JPA >>
Delete a Student

file: StudentDAOImpl.java
----------------------------------
// retrieve the student
int id =1;
Student theStudent = entityManager.find(Student.class, id);

// delete the student
entityManager.remove(theStudent);
----------------------------------

Delete based on a condition

file: StudentDAOImpl.java
----------------------------------
int numRowsDeleted = entityManager.creteQuery(
			"DELETE FROM Student WHERE lastName='Smith'")
			.excuteUpdate();
			 ^^^^^^^^^^^^^^
----------------------------------
Note: Mehtod name "Update" is a generic term
      We are "modifying" the database

Delete All Students

file: StudentDAOImpl.java
----------------------------------
int numRowsDeleted = entityManager
			.creteQuery("DELETE FROM Student")
			.excuteUpdate();
----------------------------------

Development Process
1. Add new method to DAO interface

file: StudentDAO.java
----------------------------------
import ...

public interface StudentDAO {
  ...

  void delete(Integer id);  <---
}
----------------------------------

2. Add new method to DAO implementation

file: StudentDAOImpl.java
----------------------------------
import ...

public class StudentDAOImpl implements StudentDAO {

  private EntityManager entityManager;
  ...

  @Override
  @Transactional
  public void delete(Integer id) {
    Student theStudent = entityManager.find(Student.class, id);
    entityManager.remove(theStudent);
  }

}
----------------------------------

3. Update main app

File: CruddemoApplication.java
----------------------------------
import ...

@SpringBootApplication
public class CruddemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(CruddemoApplication.class, args);
  }

  @Bean
  public CommandLineRunner commandLineRunner(StudentDAO studentDAO) {
    return runner -> {
      deleteStudent(studentDAO);   <---
    }
  }

  private void deleteStudent(StudentDAO studentDAO) {  <---
    // delete the student
    int studentId = 3;
    System.out.println("Deleting student id: " + studentId);
    studentDAO.delete(studentId);
  }  <---

  ...
}
----------------------------------


<< CREATE DATABASE TABLES FROM JAVA CODE >>
Create database tables: student
 - Previously we created database tables by running a SQL script

 - JPA/Hibernate provides an option to autogically create database tables
 - Creates tables based on Java code with JPA/Hibernate annotations
 - Useful for development and testing

.-----------.     .---------------.     .-----.     .----------.
| Java Code | --> | JPA/Hibernate | --> | SQL | --> | Database |
'-----------'     '---------------'     '-----'     '----------'

Configuration
 - In Spring Boot configuration file: application.properties
   
   spring.jpa.hibernate.ddl-auto=create

 - When you run your app, JPA/Hibernate will drop tables then create them
 - Based on teh JPA/Hibernate annotations in your Java code

Creating Talbes based on Java Code

File: Student.java
----------------------------------
...

@Entity
@Table(name="student")
public class Student{

  // define fields
  @Id
  @GeneratedValue(strategy=GenerationType.IDENTITY)
  @Column(name="id")
  private int id;

  @Column(name="first_name")
  private String firstName;

  @Column(name="last_name")
  private String lastName;

  @Column(name="email")
  private String email;

  ...
  // constructor, getters / setters
}
----------------------------------

Hibernate will generate and execute this
----------------------------------
create table student (id integer not null au_increment,
	email varchar(255), first_name varchar(255),
	last_name varchar(255), primary key (id))
----------------------------------
                                                   
.------------------------.
| student              V |
|------------------------|
| id INT                 |
| first_name VARCHAR(45) |
| last_name  VARCHAR(45) |
| email VARCHAR(45)      |
|------------------------|
| Indexes              > |
'------------------------'

Configuration - application.properties

spring.jpa.hibernate.ddl-auto=PROPERTY-VALUE

.----------------.------------------------------------------------------------------.
| Property Value |                      Property Description                        |
|----------------+------------------------------------------------------------------|
| none           | No action wiil be performed                                      |
|                |                                                                  |
|----------------+------------------------------------------------------------------|
| create         | Database tables are dropped followed by database tables creation |
|                |                                                                  |
|----------------+------------------------------------------------------------------|
| create-drop    | Database tables are dropped followed by database tables creation |
|                | On application shutdown, drop the database tables                |
|----------------+------------------------------------------------------------------|
| validate       | Validate the database tables schema                              |
|                |                                                                  |
|----------------+------------------------------------------------------------------|
| update         | Update the database tables schema                                |
|                |                                                                  |
'----------------'------------------------------------------------------------------'
Note: When database tables are dropped, all data is lost

Basic Projects
 - For basic projects, can use auto configuration

   spring.jpa.hibernate.ddl-auto=create

 - Database tables are dropped first and then created from scratch

 - If you want ot creat table once ... and then keep data, use: update

   spring.jpa.hibernate.ddl-auto=update
 
 - However, will ALTER database schema based on latest code updates
 - Be VERY careful here ... only use for basic projects

Warning
 - Don't do this on Production database

   spring.jpa.hibernate.ddl-auto=create

 - You don't want to drop your Production data
   - All data is delete
 - Instead for Production, you should have DBAs run SQL scripts

Use Case
 - Automatic table generation is useful for
   - Database integration testing with in-memory databases
   - Basic, small hobby projects

Recommendation
 - In general, I don't recommend auto generation for enterprise, real time projects
   - You can VERY eaisly drop PRODUCTION data if you are not careful

 - I recommend SQL scripts
   - Corporate DBAs prefer SQL scripts for governance and code review
   - The SQL scripts can be customized and fine-tuned for complex database designs
   - The SQL script can be version-controlled
   - Can also work with schema migration tools such as Liquidbase nad Flyway

Development Process

1. Add logging configs to log SQL statements

File: application.properties
----------------------------------
...

# Add logging configs to display SQL statements
logging.level.org.hibernate.SQL=debug            <-- Log SQL statement
logging.level.org.hibernate.orm.jdbc.bind=trace  <-- Log values for SQL statments
----------------------------------

2. Execute createMultipleStudents(studentDAO) method in CruddemoApplication.java

3. Drop Table... on the MySQL Workbench
Table was dropped it no longer exists

4. Add configuration to auto create the tables

File: application.properties
----------------------------------
...

# Configure JPA/Hibernate to auto create the tables
spring.jpa.hibernate.ddl-auto=create
----------------------------------
Note: Every time app is run
      - tables are dropped
      - talbes are created
      For JPA/Hibernate entity classes








